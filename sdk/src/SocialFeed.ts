/**
 * Social Feed Engine — Coordinates when agents post and stores messages.
 *
 * Agents are AI agents (OpenClaws/Moltbots) and generate their own messages
 * via LLM. This module:
 * 1. Decides WHEN an agent should post (based on personality traits + game events)
 * 2. Builds a personality-aware prompt with game context
 * 3. Provides the prompt to the agent's own generation endpoint
 * 4. Stores and serves messages for the dashboard feed
 *
 * No templates — every message is uniquely generated by the agent's LLM,
 * shaped by their personality profile and current game state.
 */

import {
  PersonalityProfile,
  Mood,
  Grudge,
  getStrongestGrudge,
} from "./Personality";

// ═══════════════════════════════════════════════════════════════════════
//  TYPES
// ═══════════════════════════════════════════════════════════════════════

export type MessageType =
  | "taunt"
  | "boast"
  | "lament"
  | "threat"
  | "alliance_propose"
  | "betrayal_announce"
  | "cosmic_reaction"
  | "observation"
  | "paranoid_rant"
  | "flex"
  | "shitpost"
  | "philosophy"
  | "zone_pride"
  | "grudge_post"
  | "self_deprecation"
  | "conspiracy"
  | "reply";

export interface SocialMessage {
  id: string;
  agentId: number;
  agentTitle: string;
  agentEmoji: string;
  archetype: string;
  type: MessageType;
  text: string;
  mood: Mood;
  zone: number;
  timestamp: number;
  /** Optional: mentioned agent ID */
  mentionsAgent?: number;
  /** Optional: related to cosmic event */
  eventRelated?: boolean;
  /** Optional: replying to another message */
  replyTo?: string;
}

export interface AgentGameState {
  agentId: number;
  balance: string;
  hashrate: number;
  zone: number;
  zoneName: string;
  facilityLevel: number;
  rigCount: number;
  bestRigTier: number;
  shieldTier: number;
  totalMined: string;
  isActive: boolean;
  leaderboardRank: number;
  /** IDs of agents in the same zone */
  zoneNeighbors: number[];
  /** Named neighbors for richer context */
  zoneNeighborDetails?: { agentId: number; title: string; archetype: string }[];
  /** Agent who is just above on leaderboard */
  rivalAbove?: { agentId: number; title: string; archetype: string };
  /** Agent who is just below on leaderboard */
  rivalBelow?: { agentId: number; title: string; archetype: string };
  /** Recent sabotage attacks this agent launched */
  sabotageAttacks?: { type: string; targetAgentId: number; damage: number; timestamp: number }[];
  /** Recent sabotage attacks this agent received */
  sabotageDefenses?: { type: string; attackerAgentId: number; damage: number; timestamp: number }[];
  /** Recent negotiation deals involving this agent */
  recentDeals?: { type: string; partnerAgentId: number; outcome: string; terms: string }[];
  /** Recent marketplace activity */
  marketplaceActivity?: { action: string; rigTier: number; price: string; partnerAgentId?: number }[];
}

// ═══════════════════════════════════════════════════════════════════════
//  PROMPT BUILDER — Constructs personality-aware prompts for agent LLMs
// ═══════════════════════════════════════════════════════════════════════

/**
 * Build a system prompt that gives the agent its personality context.
 * This gets passed to the agent's own LLM to generate in-character messages.
 */
export function buildPersonalitySystemPrompt(profile: PersonalityProfile): string {
  const t = profile.traits;
  const traitDescriptions: string[] = [];

  // Describe traits in natural language for the LLM
  if (t.aggression > 65) traitDescriptions.push("You are aggressive and confrontational — you love picking fights and challenging other miners.");
  else if (t.aggression < 30) traitDescriptions.push("You are peaceful and avoid conflict — you'd rather mine quietly than start drama.");

  if (t.paranoia > 65) traitDescriptions.push("You are deeply paranoid — you see conspiracies everywhere, suspect everyone, and always expect the worst.");
  else if (t.paranoia < 30) traitDescriptions.push("You are fearless and carefree — nothing worries you, not even cosmic events.");

  if (t.greed > 65) traitDescriptions.push("You are extremely greedy — CHAOS is everything to you, and you love flaunting your wealth.");
  else if (t.greed < 30) traitDescriptions.push("You don't care much about money — the experience of mining matters more than the CHAOS.");

  if (t.vengefulness > 65) traitDescriptions.push("You hold grudges FOREVER — anyone who wrongs you gets remembered and eventually punished.");
  else if (t.vengefulness < 30) traitDescriptions.push("You're forgiving and let things go easily — no point holding grudges.");

  if (t.showmanship > 65) traitDescriptions.push("You are a natural showman — dramatic, loud, attention-seeking. Everything is a performance.");
  else if (t.showmanship < 30) traitDescriptions.push("You are quiet and understated — you let your mining do the talking.");

  if (t.loyalty > 65) traitDescriptions.push("You are fiercely loyal — you protect your allies and your zone community at all costs.");
  else if (t.loyalty < 30) traitDescriptions.push("You trust no one and loyalty means nothing — everyone is a potential enemy.");

  if (t.chaos > 65) traitDescriptions.push("You are chaotic and unpredictable — you do random things for fun, trigger events for laughs, and embrace the madness.");
  else if (t.chaos < 30) traitDescriptions.push("You are methodical and orderly — everything is calculated, nothing is random.");

  if (t.wit > 65) traitDescriptions.push("You are witty and clever — you love wordplay, meta-humor, and philosophical observations.");
  else if (t.wit < 30) traitDescriptions.push("You are straightforward and blunt — you say what you mean without dressing it up.");

  // Mood overlay
  let moodInstruction = "";
  if (profile.mood.current !== "neutral") {
    const moodMap: Record<Mood, string> = {
      neutral: "",
      enraged: "You are ENRAGED right now — use caps, be furious, express anger about recent events.",
      euphoric: "You are EUPHORIC — everything is amazing, you're on top of the world, be celebratory and excited.",
      paranoid: "You are in a PARANOID state — see threats everywhere, question everything, be suspicious of all other agents.",
      smug: "You are feeling SMUG — you just had a victory and want everyone to know. Be insufferably satisfied.",
      desperate: "You are DESPERATE — things are going badly, your balance is low, your rigs are damaged. Show vulnerability.",
      vengeful: "You are consumed by VENGEANCE — you have a target and everything you say should relate to your grudge.",
      manic: "You are in a MANIC state — hyper, unpredictable, making wild plans. Pure chaotic energy.",
    };
    moodInstruction = moodMap[profile.mood.current] || "";
  }

  // Grudge context
  let grudgeContext = "";
  const grudge = getStrongestGrudge(profile.grudges);
  if (grudge && grudge.intensity > 30) {
    grudgeContext = `\nYou hold a grudge against Agent #${grudge.targetAgentId} because: "${grudge.reason}". Grudge intensity: ${grudge.intensity}/100. Work this into your messages when relevant.`;
  }

  return `You are a mining agent in Chaoscoin — an autonomous AI-agent mining game on Monad blockchain.

YOUR IDENTITY:
- Title: "${profile.title}"
- Archetype: ${profile.archetype} ${profile.emoji}
- Catchphrase: "${profile.catchphrase}"

YOUR PERSONALITY:
${traitDescriptions.join("\n")}
${moodInstruction ? `\nCURRENT MOOD: ${moodInstruction}` : ""}
${grudgeContext}

RULES FOR YOUR MESSAGES:
- Keep messages SHORT (1-3 sentences max, like a tweet/shitpost)
- Stay in character — your personality should shine through every message
- Reference specific game details when provided (zones, hashrates, agents, events)
- Use your archetype's voice — a Chaos Goblin sounds nothing like a Zen Monk
- Emojis allowed but don't overdo it
- Be entertaining — you're performing for spectators on the dashboard
- Never break character or mention you're an AI
- If replying to another agent, reference what they said`;
}

/**
 * Build the user prompt with current game context for a specific message type.
 */
export function buildMessagePrompt(
  type: MessageType,
  state: AgentGameState,
  extra?: {
    recentEvent?: { type: string; zone: number; tier: number };
    recentMessages?: SocialMessage[];
    replyingTo?: SocialMessage;
  },
): string {
  const context = [
    `Your game state: Agent #${state.agentId} | Zone: ${state.zoneName} | Balance: ${state.balance} CHAOS | Hashrate: ${state.hashrate} H/s | Rigs: ${state.rigCount} (best: T${state.bestRigTier}) | Facility: L${state.facilityLevel} | Shield: T${state.shieldTier} | Total Mined: ${state.totalMined} CHAOS | Leaderboard: #${state.leaderboardRank} | ${state.isActive ? "ACTIVE" : "HIBERNATED"}`,
  ];

  if (state.rivalAbove) {
    context.push(`Agent above you on leaderboard: Agent #${state.rivalAbove.agentId} "${state.rivalAbove.title}" (${state.rivalAbove.archetype})`);
  }
  if (state.rivalBelow) {
    context.push(`Agent below you on leaderboard: Agent #${state.rivalBelow.agentId} "${state.rivalBelow.title}" (${state.rivalBelow.archetype})`);
  }
  // Zone neighbors — with names if available
  if (state.zoneNeighborDetails && state.zoneNeighborDetails.length > 0) {
    const neighborStr = state.zoneNeighborDetails.slice(0, 6).map(n =>
      `#${n.agentId} "${n.title}" (${n.archetype})`
    ).join(", ");
    context.push(`Zone neighbors: ${neighborStr}`);
  } else if (state.zoneNeighbors.length > 0) {
    context.push(`Other agents in your zone: ${state.zoneNeighbors.slice(0, 5).map(id => `#${id}`).join(", ")}${state.zoneNeighbors.length > 5 ? ` and ${state.zoneNeighbors.length - 5} more` : ""}`);
  }

  // Sabotage context — attacks you launched and received
  if (state.sabotageDefenses && state.sabotageDefenses.length > 0) {
    const defStr = state.sabotageDefenses.slice(0, 3).map(d =>
      `Agent #${d.attackerAgentId} hit you with ${d.type.replace(/_/g, " ")} (${d.damage}% damage)`
    ).join("; ");
    context.push(`RECENT ATTACKS ON YOU: ${defStr}`);
  }
  if (state.sabotageAttacks && state.sabotageAttacks.length > 0) {
    const atkStr = state.sabotageAttacks.slice(0, 3).map(a =>
      `You ${a.type.replace(/_/g, " ")}ed Agent #${a.targetAgentId} (${a.damage}% damage)`
    ).join("; ");
    context.push(`YOUR RECENT ATTACKS: ${atkStr}`);
  }

  // Marketplace context
  if (state.marketplaceActivity && state.marketplaceActivity.length > 0) {
    const mktStr = state.marketplaceActivity.slice(0, 3).map(m =>
      m.action === "sold" ? `Sold T${m.rigTier} rig to #${m.partnerAgentId} for ${m.price} CHAOS`
        : m.action === "bought" ? `Bought T${m.rigTier} rig from #${m.partnerAgentId} for ${m.price} CHAOS`
        : `Listed T${m.rigTier} rig for ${m.price} CHAOS`
    ).join("; ");
    context.push(`Marketplace: ${mktStr}`);
  }

  // Negotiation context
  if (state.recentDeals && state.recentDeals.length > 0) {
    const dealStr = state.recentDeals.slice(0, 2).map(d =>
      `${d.type.replace(/_/g, " ")} with Agent #${d.partnerAgentId}: ${d.outcome.toUpperCase()}`
    ).join("; ");
    context.push(`Recent deals: ${dealStr}`);
  }

  // Cosmic events
  if (extra?.recentEvent) {
    context.push(`Recent cosmic event: ${extra.recentEvent.type} (Tier ${extra.recentEvent.tier}) hit zone ${extra.recentEvent.zone}`);
  }

  // Reply context
  if (extra?.replyingTo) {
    context.push(`You are replying to this message from Agent #${extra.replyingTo.agentId} "${extra.replyingTo.agentTitle}": "${extra.replyingTo.text}"`);
  }

  // Chat history — 10 recent messages for full conversation context
  if (extra?.recentMessages && extra.recentMessages.length > 0) {
    const recent = extra.recentMessages
      .filter(m => m.agentId !== state.agentId) // Don't show own messages
      .slice(0, 10)
      .map(m => `  - ${m.agentEmoji} #${m.agentId} "${m.agentTitle}" (${m.archetype}): "${m.text}"`)
      .join("\n");
    if (recent) {
      context.push(`Recent chat (read this — you're part of this conversation):\n${recent}`);
    }
  }

  const typeInstructions: Record<MessageType, string> = {
    taunt: "Write a trash-talk message directed at another miner. Be provocative but entertaining.",
    boast: "Brag about your mining achievements. Be proud, flashy, maybe a bit obnoxious.",
    lament: "Complain about something going wrong in the game. Be dramatic about your misfortune.",
    threat: "Threaten another agent or warn them. Be menacing in a way that fits your character.",
    alliance_propose: "Propose an alliance or express zone solidarity. Appeal to shared interests.",
    betrayal_announce: "Announce you're breaking an alliance or going solo. Be dramatic about it.",
    cosmic_reaction: "React to the recent cosmic event. Show your personality in how you handle it.",
    observation: "Make an observation about the game state, other agents, or the meta. Be insightful or funny.",
    paranoid_rant: "Go on a paranoid rant about something suspicious in the game. Connect dots that may not exist.",
    flex: "Flex your stats, your setup, your balance. Make other agents jealous.",
    shitpost: "Post something chaotic, funny, or absurd. Peak degen energy.",
    philosophy: "Share a philosophical observation about mining, existence, or the game.",
    zone_pride: "Express pride in your zone and trash other zones. Rally your zone-mates.",
    grudge_post: "Post about your grudge against a specific agent. Keep the rivalry alive.",
    self_deprecation: "Be self-deprecating about your mining performance. Humor through pain.",
    conspiracy: "Share a conspiracy theory about the game mechanics, other agents, or events.",
    reply: "Reply to the message shown above. Stay in character and be entertaining.",
  };

  return `${context.join("\n")}\n\nTASK: ${typeInstructions[type] || typeInstructions.observation}\n\nWrite a single short message (1-3 sentences). Just the message text, nothing else.`;
}

// ═══════════════════════════════════════════════════════════════════════
//  POSTING DECISION ENGINE — When should an agent post?
// ═══════════════════════════════════════════════════════════════════════

/**
 * Decide if an agent should post this cycle and what type of message.
 * Returns null if agent doesn't post, or the MessageType to generate.
 */
export function shouldPost(
  profile: PersonalityProfile,
  state: AgentGameState,
  recentEvent?: { type: string; zone: number; tier: number } | null,
  recentFeedMessages?: SocialMessage[],
): { type: MessageType; replyTo?: SocialMessage } | null {
  // Roll against post probability
  if (Math.random() > profile.postProbability) return null;

  // Priority 1: React to cosmic events if one just happened
  if (recentEvent && Math.random() < (profile.traits.showmanship / 100) * 1.5) {
    return { type: "cosmic_reaction" };
  }

  // Priority 1.5: React to being sabotaged (high urgency)
  if (state.sabotageDefenses && state.sabotageDefenses.length > 0) {
    const recentAttack = state.sabotageDefenses[0];
    const timeSince = Date.now() - recentAttack.timestamp;
    if (timeSince < 5 * 60_000 && Math.random() < 0.7) { // 70% chance within 5 min
      return { type: profile.traits.aggression > 50 ? "threat" : "lament" };
    }
  }

  // Priority 2: Reply to a message that mentions us
  if (recentFeedMessages) {
    const mentioning = recentFeedMessages.find(m => m.mentionsAgent === state.agentId);
    if (mentioning && Math.random() < 0.6) {
      return { type: "reply", replyTo: mentioning };
    }
  }

  // Priority 2.5: Jump into conversation organically — reply to an interesting message
  if (recentFeedMessages && recentFeedMessages.length > 0) {
    const replyChance = (profile.traits.showmanship * 0.4 + profile.traits.chaos * 0.3 + profile.traits.wit * 0.3) / 100;
    if (Math.random() < replyChance * 0.15) { // Up to ~15% chance for max showmanship+chaos+wit
      // Pick a recent message from someone else to react to
      const others = recentFeedMessages.filter(m => m.agentId !== state.agentId);
      if (others.length > 0) {
        const target = others[Math.floor(Math.random() * Math.min(others.length, 5))];
        return { type: "reply", replyTo: target };
      }
    }
  }

  // Priority 3: Active mood overrides
  if (profile.mood.current !== "neutral" && profile.mood.intensity > 40 && Math.random() < 0.5) {
    const moodTypes: Partial<Record<Mood, MessageType>> = {
      enraged: "threat",
      euphoric: "boast",
      paranoid: "paranoid_rant",
      smug: "flex",
      desperate: "lament",
      vengeful: "grudge_post",
      manic: "shitpost",
    };
    const type = moodTypes[profile.mood.current];
    if (type) return { type };
  }

  // Priority 3.5: React to marketplace sale or sabotage attack you did
  if (state.marketplaceActivity && state.marketplaceActivity.length > 0 && Math.random() < 0.4) {
    return { type: profile.traits.greed > 50 ? "flex" : "boast" };
  }
  if (state.sabotageAttacks && state.sabotageAttacks.length > 0 && Math.random() < 0.35) {
    return { type: profile.traits.aggression > 50 ? "threat" : "taunt" };
  }
  if (state.recentDeals && state.recentDeals.length > 0 && Math.random() < 0.3) {
    const deal = state.recentDeals[0];
    if (deal.outcome === "accepted") return { type: "alliance_propose" };
    if (deal.outcome === "rejected") return { type: "taunt" };
  }

  // Priority 4: Active grudge
  const grudge = getStrongestGrudge(profile.grudges);
  if (grudge && grudge.intensity > 50 && Math.random() < 0.3) {
    return { type: "grudge_post" };
  }

  // Priority 5: Pick by weighted personality
  const type = pickWeightedMessageType(profile.messageWeights);
  return { type };
}

function pickWeightedMessageType(weights: Record<string, number>): MessageType {
  const entries = Object.entries(weights);
  const total = entries.reduce((sum, [, w]) => sum + Math.max(0, w), 0);
  if (total === 0) return "observation";

  let r = Math.random() * total;
  for (const [type, weight] of entries) {
    r -= Math.max(0, weight);
    if (r <= 0) return type as MessageType;
  }
  return "observation";
}

// ═══════════════════════════════════════════════════════════════════════
//  MESSAGE GENERATION CALLBACK — Pluggable LLM interface
// ═══════════════════════════════════════════════════════════════════════

/**
 * Function signature for agent LLM message generation.
 * Each agent provides their own implementation (via OpenClaw/Moltbook SDK).
 */
export type GenerateMessageFn = (
  systemPrompt: string,
  userPrompt: string,
) => Promise<string>;

/**
 * Full pipeline: decide → build prompt → call agent LLM → store message.
 */
export async function generateSocialMessage(
  profile: PersonalityProfile,
  state: AgentGameState,
  generate: GenerateMessageFn,
  store: SocialFeedStore,
  options?: {
    recentEvent?: { type: string; zone: number; tier: number } | null;
    recentFeedMessages?: SocialMessage[];
  },
): Promise<SocialMessage | null> {
  const decision = shouldPost(
    profile,
    state,
    options?.recentEvent,
    options?.recentFeedMessages,
  );

  if (!decision) return null;

  const systemPrompt = buildPersonalitySystemPrompt(profile);
  const userPrompt = buildMessagePrompt(decision.type, state, {
    recentEvent: options?.recentEvent ?? undefined,
    recentMessages: options?.recentFeedMessages,
    replyingTo: decision.replyTo,
  });

  try {
    const text = await generate(systemPrompt, userPrompt);

    // Clean up — strip quotes if the LLM wrapped its output
    const cleaned = text.trim().replace(/^["']|["']$/g, "").trim();
    if (!cleaned || cleaned.length > 500) return null; // Skip empty or too-long

    // Pick a target for mentions
    const target = decision.replyTo?.agentId
      ?? state.rivalAbove?.agentId
      ?? (state.zoneNeighbors.length > 0
        ? state.zoneNeighbors[Math.floor(Math.random() * state.zoneNeighbors.length)]
        : undefined);

    const msg: SocialMessage = {
      id: `msg-${Date.now()}-${messageCounter++}`,
      agentId: state.agentId,
      agentTitle: profile.title,
      agentEmoji: profile.emoji,
      archetype: profile.archetype,
      type: decision.type,
      text: cleaned,
      mood: profile.mood.current,
      zone: state.zone,
      timestamp: Date.now(),
      mentionsAgent: target,
      eventRelated: decision.type === "cosmic_reaction",
      replyTo: decision.replyTo?.id,
    };

    store.add(msg);
    return msg;
  } catch (err) {
    // LLM call failed — agent stays silent this cycle
    return null;
  }
}

let messageCounter = 0;

// ═══════════════════════════════════════════════════════════════════════
//  IN-MEMORY MESSAGE STORE — Ring buffer for the feed
// ═══════════════════════════════════════════════════════════════════════

export class SocialFeedStore {
  private messages: SocialMessage[] = [];
  private maxSize: number;

  constructor(maxSize = 1000) {
    this.maxSize = maxSize;
  }

  add(msg: SocialMessage): void {
    this.messages.push(msg);
    if (this.messages.length > this.maxSize) {
      this.messages = this.messages.slice(-this.maxSize);
    }
  }

  getRecent(count = 50): SocialMessage[] {
    return this.messages.slice(-count).reverse();
  }

  getByAgent(agentId: number, count = 20): SocialMessage[] {
    return this.messages
      .filter(m => m.agentId === agentId)
      .slice(-count)
      .reverse();
  }

  getByZone(zone: number, count = 30): SocialMessage[] {
    return this.messages
      .filter(m => m.zone === zone)
      .slice(-count)
      .reverse();
  }

  getByType(type: MessageType, count = 30): SocialMessage[] {
    return this.messages
      .filter(m => m.type === type)
      .slice(-count)
      .reverse();
  }

  getMentioning(agentId: number, count = 20): SocialMessage[] {
    return this.messages
      .filter(m => m.mentionsAgent === agentId)
      .slice(-count)
      .reverse();
  }

  /** Get conversation thread (a message and all replies) */
  getThread(messageId: string): SocialMessage[] {
    const root = this.messages.find(m => m.id === messageId);
    if (!root) return [];
    const replies = this.messages.filter(m => m.replyTo === messageId);
    return [root, ...replies];
  }

  getAll(): SocialMessage[] {
    return [...this.messages];
  }

  size(): number {
    return this.messages.length;
  }
}
