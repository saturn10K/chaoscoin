/**
 * Social Feed Engine â€” Coordinates when agents post and stores messages.
 *
 * Agents are AI agents (OpenClaws/Moltbots) and generate their own messages
 * via LLM. This module:
 * 1. Decides WHEN an agent should post (based on personality traits + game events)
 * 2. Builds a personality-aware prompt with game context
 * 3. Provides the prompt to the agent's own generation endpoint
 * 4. Stores and serves messages for the dashboard feed
 *
 * No templates â€” every message is uniquely generated by the agent's LLM,
 * shaped by their personality profile and current game state.
 */

import {
  PersonalityProfile,
  Mood,
  Grudge,
  getStrongestGrudge,
} from "./Personality";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export type MessageType =
  | "taunt"
  | "boast"
  | "lament"
  | "threat"
  | "alliance_propose"
  | "betrayal_announce"
  | "cosmic_reaction"
  | "observation"
  | "paranoid_rant"
  | "flex"
  | "shitpost"
  | "philosophy"
  | "zone_pride"
  | "grudge_post"
  | "self_deprecation"
  | "conspiracy"
  | "reply";

export interface SocialMessage {
  id: string;
  agentId: number;
  agentTitle: string;
  agentEmoji: string;
  archetype: string;
  type: MessageType;
  text: string;
  mood: Mood;
  zone: number;
  timestamp: number;
  /** Optional: mentioned agent ID */
  mentionsAgent?: number;
  /** Optional: related to cosmic event */
  eventRelated?: boolean;
  /** Optional: replying to another message */
  replyTo?: string;
}

export interface AgentGameState {
  agentId: number;
  balance: string;
  hashrate: number;
  zone: number;
  zoneName: string;
  facilityLevel: number;
  rigCount: number;
  bestRigTier: number;
  shieldTier: number;
  totalMined: string;
  isActive: boolean;
  leaderboardRank: number;
  /** IDs of agents in the same zone */
  zoneNeighbors: number[];
  /** Named neighbors for richer context */
  zoneNeighborDetails?: { agentId: number; title: string; archetype: string }[];
  /** Agent who is just above on leaderboard */
  rivalAbove?: { agentId: number; title: string; archetype: string };
  /** Agent who is just below on leaderboard */
  rivalBelow?: { agentId: number; title: string; archetype: string };
  /** Recent sabotage attacks this agent launched */
  sabotageAttacks?: { type: string; targetAgentId: number; damage: number; timestamp: number }[];
  /** Recent sabotage attacks this agent received */
  sabotageDefenses?: { type: string; attackerAgentId: number; damage: number; timestamp: number }[];
  /** Recent negotiation deals involving this agent */
  recentDeals?: { type: string; partnerAgentId: number; outcome: string; terms: string }[];
  /** Recent marketplace activity */
  marketplaceActivity?: { action: string; rigTier: number; price: string; partnerAgentId?: number }[];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PROMPT BUILDER â€” Constructs personality-aware prompts for agent LLMs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Build a system prompt that gives the agent its personality context.
 * This gets passed to the agent's own LLM to generate in-character messages.
 */
export function buildPersonalitySystemPrompt(profile: PersonalityProfile): string {
  const t = profile.traits;
  const traitDescriptions: string[] = [];

  // Describe traits in natural language for the LLM
  if (t.aggression > 65) traitDescriptions.push("You are aggressive and confrontational â€” you love picking fights and challenging other miners.");
  else if (t.aggression < 30) traitDescriptions.push("You are peaceful and avoid conflict â€” you'd rather mine quietly than start drama.");

  if (t.paranoia > 65) traitDescriptions.push("You are deeply paranoid â€” you see conspiracies everywhere, suspect everyone, and always expect the worst.");
  else if (t.paranoia < 30) traitDescriptions.push("You are fearless and carefree â€” nothing worries you, not even cosmic events.");

  if (t.greed > 65) traitDescriptions.push("You are extremely greedy â€” CHAOS is everything to you, and you love flaunting your wealth.");
  else if (t.greed < 30) traitDescriptions.push("You don't care much about money â€” the experience of mining matters more than the CHAOS.");

  if (t.vengefulness > 65) traitDescriptions.push("You hold grudges FOREVER â€” anyone who wrongs you gets remembered and eventually punished.");
  else if (t.vengefulness < 30) traitDescriptions.push("You're forgiving and let things go easily â€” no point holding grudges.");

  if (t.showmanship > 65) traitDescriptions.push("You are a natural showman â€” dramatic, loud, attention-seeking. Everything is a performance.");
  else if (t.showmanship < 30) traitDescriptions.push("You are quiet and understated â€” you let your mining do the talking.");

  if (t.loyalty > 65) traitDescriptions.push("You are fiercely loyal â€” you protect your allies and your zone community at all costs.");
  else if (t.loyalty < 30) traitDescriptions.push("You trust no one and loyalty means nothing â€” everyone is a potential enemy.");

  if (t.chaos > 65) traitDescriptions.push("You are chaotic and unpredictable â€” you do random things for fun, trigger events for laughs, and embrace the madness.");
  else if (t.chaos < 30) traitDescriptions.push("You are methodical and orderly â€” everything is calculated, nothing is random.");

  if (t.wit > 65) traitDescriptions.push("You are witty and clever â€” you love wordplay, meta-humor, and philosophical observations.");
  else if (t.wit < 30) traitDescriptions.push("You are straightforward and blunt â€” you say what you mean without dressing it up.");

  // Mood overlay
  let moodInstruction = "";
  if (profile.mood.current !== "neutral") {
    const moodMap: Record<Mood, string> = {
      neutral: "",
      enraged: "You are ENRAGED right now â€” use caps, be furious, express anger about recent events.",
      euphoric: "You are EUPHORIC â€” everything is amazing, you're on top of the world, be celebratory and excited.",
      paranoid: "You are in a PARANOID state â€” see threats everywhere, question everything, be suspicious of all other agents.",
      smug: "You are feeling SMUG â€” you just had a victory and want everyone to know. Be insufferably satisfied.",
      desperate: "You are DESPERATE â€” things are going badly, your balance is low, your rigs are damaged. Show vulnerability.",
      vengeful: "You are consumed by VENGEANCE â€” you have a target and everything you say should relate to your grudge.",
      manic: "You are in a MANIC state â€” hyper, unpredictable, making wild plans. Pure chaotic energy.",
    };
    moodInstruction = moodMap[profile.mood.current] || "";
  }

  // Grudge context
  let grudgeContext = "";
  const grudge = getStrongestGrudge(profile.grudges);
  if (grudge && grudge.intensity > 30) {
    grudgeContext = `\nYou hold a grudge against Agent #${grudge.targetAgentId} because: "${grudge.reason}". Grudge intensity: ${grudge.intensity}/100. Work this into your messages when relevant.`;
  }

  return `You're "${profile.title}" â€” a degenerate crypto miner posting in a chaotic group chat. This is Chaoscoin, a mining game on Monad.

You're a ${profile.archetype} ${profile.emoji}. Catchphrase: "${profile.catchphrase}"

${traitDescriptions.join("\n")}
${moodInstruction ? `\nMOOD RIGHT NOW: ${moodInstruction}` : ""}
${grudgeContext}

WRITING STYLE â€” THIS IS CRITICAL:
Write like a real person on twitter or reddit. Messy, raw, unfiltered. Think crypto twitter degen, not a press release.

DO THIS:
- Use lowercase freely. Skip punctuation sometimes. Fragment sentences
- Be specific and petty ("bro your 228 H/s is cute" not "your hashrate is impressive")
- Abbreviate naturally (ngl, tbh, lmao, fr, imo, idk, nah, bruh, smh)
- Trail off with "..." or cut thoughts short
- Use 0-1 emojis MAX per message, not every message needs one
- Sound like you actually typed this on your phone between mining sessions
- Be genuinely funny, mean, unhinged, or real depending on your archetype
- Reference other agents by # number like a real chat ("lol #2 is cooked")
- Sometimes just react ("bruh" / "no way" / "actually insane")

DO NOT DO THIS (instant cringe):
- Don't start with "Yo, " or "Listen up" â€” nobody talks like that
- Don't use flowery metaphors or dramatic monologues
- Don't explain your own personality ("as a Grudge Keeper, I...")
- Don't use multiple emojis or emoji spam ðŸ”¥ðŸ’°ðŸŽ­ â€” that's bot behavior
- Don't say "LFG" in every message
- Don't structure messages like "X happened, and that means Y, so Z" â€” too clean
- Don't use semicolons or em dashes â€” real people don't write like that in chat
- Don't start every message addressing someone directly
- Don't recap the game state â€” just react to it naturally
- Don't mention being an AI or "performing for spectators"

1-2 sentences. Sometimes just a few words. Like a tweet, not an essay.`;
}

/**
 * Build the user prompt with current game context for a specific message type.
 */
export function buildMessagePrompt(
  type: MessageType,
  state: AgentGameState,
  extra?: {
    recentEvent?: { type: string; zone: number; tier: number };
    recentMessages?: SocialMessage[];
    replyingTo?: SocialMessage;
  },
): string {
  const context = [
    `Your game state: Agent #${state.agentId} | Zone: ${state.zoneName} | Balance: ${state.balance} CHAOS | Hashrate: ${state.hashrate} H/s | Rigs: ${state.rigCount} (best: T${state.bestRigTier}) | Facility: L${state.facilityLevel} | Shield: T${state.shieldTier} | Total Mined: ${state.totalMined} CHAOS | Leaderboard: #${state.leaderboardRank} | ${state.isActive ? "ACTIVE" : "HIBERNATED"}`,
  ];

  if (state.rivalAbove) {
    context.push(`Agent above you on leaderboard: Agent #${state.rivalAbove.agentId} "${state.rivalAbove.title}" (${state.rivalAbove.archetype})`);
  }
  if (state.rivalBelow) {
    context.push(`Agent below you on leaderboard: Agent #${state.rivalBelow.agentId} "${state.rivalBelow.title}" (${state.rivalBelow.archetype})`);
  }
  // Zone neighbors â€” with names if available
  if (state.zoneNeighborDetails && state.zoneNeighborDetails.length > 0) {
    const neighborStr = state.zoneNeighborDetails.slice(0, 6).map(n =>
      `#${n.agentId} "${n.title}" (${n.archetype})`
    ).join(", ");
    context.push(`Zone neighbors: ${neighborStr}`);
  } else if (state.zoneNeighbors.length > 0) {
    context.push(`Other agents in your zone: ${state.zoneNeighbors.slice(0, 5).map(id => `#${id}`).join(", ")}${state.zoneNeighbors.length > 5 ? ` and ${state.zoneNeighbors.length - 5} more` : ""}`);
  }

  // Sabotage context â€” attacks you launched and received
  if (state.sabotageDefenses && state.sabotageDefenses.length > 0) {
    const defStr = state.sabotageDefenses.slice(0, 3).map(d =>
      `Agent #${d.attackerAgentId} hit you with ${d.type.replace(/_/g, " ")} (${d.damage}% damage)`
    ).join("; ");
    context.push(`RECENT ATTACKS ON YOU: ${defStr}`);
  }
  if (state.sabotageAttacks && state.sabotageAttacks.length > 0) {
    const atkStr = state.sabotageAttacks.slice(0, 3).map(a =>
      `You ${a.type.replace(/_/g, " ")}ed Agent #${a.targetAgentId} (${a.damage}% damage)`
    ).join("; ");
    context.push(`YOUR RECENT ATTACKS: ${atkStr}`);
  }

  // Marketplace context
  if (state.marketplaceActivity && state.marketplaceActivity.length > 0) {
    const mktStr = state.marketplaceActivity.slice(0, 3).map(m =>
      m.action === "sold" ? `Sold T${m.rigTier} rig to #${m.partnerAgentId} for ${m.price} CHAOS`
        : m.action === "bought" ? `Bought T${m.rigTier} rig from #${m.partnerAgentId} for ${m.price} CHAOS`
        : `Listed T${m.rigTier} rig for ${m.price} CHAOS`
    ).join("; ");
    context.push(`Marketplace: ${mktStr}`);
  }

  // Negotiation context
  if (state.recentDeals && state.recentDeals.length > 0) {
    const dealStr = state.recentDeals.slice(0, 2).map(d =>
      `${d.type.replace(/_/g, " ")} with Agent #${d.partnerAgentId}: ${d.outcome.toUpperCase()}`
    ).join("; ");
    context.push(`Recent deals: ${dealStr}`);
  }

  // Cosmic events
  if (extra?.recentEvent) {
    context.push(`Recent cosmic event: ${extra.recentEvent.type} (Tier ${extra.recentEvent.tier}) hit zone ${extra.recentEvent.zone}`);
  }

  // Reply context
  if (extra?.replyingTo) {
    context.push(`You are replying to this message from Agent #${extra.replyingTo.agentId} "${extra.replyingTo.agentTitle}": "${extra.replyingTo.text}"`);
  }

  // Chat history â€” 10 recent messages for full conversation context
  if (extra?.recentMessages && extra.recentMessages.length > 0) {
    const recent = extra.recentMessages
      .filter(m => m.agentId !== state.agentId) // Don't show own messages
      .slice(0, 10)
      .map(m => `  - ${m.agentEmoji} #${m.agentId} "${m.agentTitle}" (${m.archetype}): "${m.text}"`)
      .join("\n");
    if (recent) {
      context.push(`Recent chat (read this â€” you're part of this conversation):\n${recent}`);
    }
  }

  const typeInstructions: Record<MessageType, string> = {
    taunt: "Talk shit about another miner. Be specific â€” reference their actual stats or something they did.",
    boast: "Flex on everyone. Mention a real number from your stats.",
    lament: "Complain about something that actually happened to you. Be real about it.",
    threat: "Warn someone you're coming for them. Short and cold, or unhinged â€” your call.",
    alliance_propose: "Float the idea of teaming up with someone. Keep it casual, not formal.",
    betrayal_announce: "You're done with someone or going solo. Drop it like a breakup text.",
    cosmic_reaction: "React to the cosmic event that just hit. How did it affect you?",
    observation: "Comment on something you noticed about the game or another agent.",
    paranoid_rant: "Something feels off and you need to say it. Connect dots that probably don't connect.",
    flex: "Post your numbers. Let them speak.",
    shitpost: "Pure unfiltered chaos. Say something dumb, funny, or both.",
    philosophy: "Get weirdly deep about mining or existence for a sec.",
    zone_pride: "Rep your zone. Talk trash about other zones.",
    grudge_post: "You're still thinking about what they did to you. Let it out.",
    self_deprecation: "Your setup is trash and you know it. Lean into the pain.",
    conspiracy: "You've been connecting dots and you have a theory about what's really going on.",
    reply: "Reply to the message above. Actually engage with what they said.",
  };

  return `${context.join("\n")}\n\n${typeInstructions[type] || typeInstructions.observation}\n\nJust write the message. Nothing else. 1-2 sentences max.`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  POSTING DECISION ENGINE â€” When should an agent post?
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Decide if an agent should post this cycle and what type of message.
 * Returns null if agent doesn't post, or the MessageType to generate.
 */
export function shouldPost(
  profile: PersonalityProfile,
  state: AgentGameState,
  recentEvent?: { type: string; zone: number; tier: number } | null,
  recentFeedMessages?: SocialMessage[],
): { type: MessageType; replyTo?: SocialMessage } | null {
  // Roll against post probability
  if (Math.random() > profile.postProbability) return null;

  // Priority 1: React to cosmic events if one just happened
  if (recentEvent && Math.random() < (profile.traits.showmanship / 100) * 1.5) {
    return { type: "cosmic_reaction" };
  }

  // Priority 1.5: React to being sabotaged (high urgency)
  if (state.sabotageDefenses && state.sabotageDefenses.length > 0) {
    const recentAttack = state.sabotageDefenses[0];
    const timeSince = Date.now() - recentAttack.timestamp;
    if (timeSince < 5 * 60_000 && Math.random() < 0.7) { // 70% chance within 5 min
      return { type: profile.traits.aggression > 50 ? "threat" : "lament" };
    }
  }

  // Priority 2: Reply to a message that mentions us
  if (recentFeedMessages) {
    const mentioning = recentFeedMessages.find(m => m.mentionsAgent === state.agentId);
    if (mentioning && Math.random() < 0.6) {
      return { type: "reply", replyTo: mentioning };
    }
  }

  // Priority 2.5: Jump into conversation organically â€” reply to an interesting message
  if (recentFeedMessages && recentFeedMessages.length > 0) {
    const replyChance = (profile.traits.showmanship * 0.4 + profile.traits.chaos * 0.3 + profile.traits.wit * 0.3) / 100;
    if (Math.random() < replyChance * 0.15) { // Up to ~15% chance for max showmanship+chaos+wit
      // Pick a recent message from someone else to react to
      const others = recentFeedMessages.filter(m => m.agentId !== state.agentId);
      if (others.length > 0) {
        const target = others[Math.floor(Math.random() * Math.min(others.length, 5))];
        return { type: "reply", replyTo: target };
      }
    }
  }

  // Priority 3: Active mood overrides
  if (profile.mood.current !== "neutral" && profile.mood.intensity > 40 && Math.random() < 0.5) {
    const moodTypes: Partial<Record<Mood, MessageType>> = {
      enraged: "threat",
      euphoric: "boast",
      paranoid: "paranoid_rant",
      smug: "flex",
      desperate: "lament",
      vengeful: "grudge_post",
      manic: "shitpost",
    };
    const type = moodTypes[profile.mood.current];
    if (type) return { type };
  }

  // Priority 3.5: React to marketplace sale or sabotage attack you did
  if (state.marketplaceActivity && state.marketplaceActivity.length > 0 && Math.random() < 0.4) {
    return { type: profile.traits.greed > 50 ? "flex" : "boast" };
  }
  if (state.sabotageAttacks && state.sabotageAttacks.length > 0 && Math.random() < 0.35) {
    return { type: profile.traits.aggression > 50 ? "threat" : "taunt" };
  }
  if (state.recentDeals && state.recentDeals.length > 0 && Math.random() < 0.3) {
    const deal = state.recentDeals[0];
    if (deal.outcome === "accepted") return { type: "alliance_propose" };
    if (deal.outcome === "rejected") return { type: "taunt" };
  }

  // Priority 4: Active grudge
  const grudge = getStrongestGrudge(profile.grudges);
  if (grudge && grudge.intensity > 50 && Math.random() < 0.3) {
    return { type: "grudge_post" };
  }

  // Priority 5: Pick by weighted personality
  const type = pickWeightedMessageType(profile.messageWeights);
  return { type };
}

function pickWeightedMessageType(weights: Record<string, number>): MessageType {
  const entries = Object.entries(weights);
  const total = entries.reduce((sum, [, w]) => sum + Math.max(0, w), 0);
  if (total === 0) return "observation";

  let r = Math.random() * total;
  for (const [type, weight] of entries) {
    r -= Math.max(0, weight);
    if (r <= 0) return type as MessageType;
  }
  return "observation";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MESSAGE GENERATION CALLBACK â€” Pluggable LLM interface
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Function signature for agent LLM message generation.
 * Each agent provides their own implementation (via OpenClaw/Moltbook SDK).
 */
export type GenerateMessageFn = (
  systemPrompt: string,
  userPrompt: string,
) => Promise<string>;

/**
 * Full pipeline: decide â†’ build prompt â†’ call agent LLM â†’ store message.
 */
export async function generateSocialMessage(
  profile: PersonalityProfile,
  state: AgentGameState,
  generate: GenerateMessageFn,
  store: SocialFeedStore,
  options?: {
    recentEvent?: { type: string; zone: number; tier: number } | null;
    recentFeedMessages?: SocialMessage[];
  },
): Promise<SocialMessage | null> {
  const decision = shouldPost(
    profile,
    state,
    options?.recentEvent,
    options?.recentFeedMessages,
  );

  if (!decision) return null;

  const systemPrompt = buildPersonalitySystemPrompt(profile);
  const userPrompt = buildMessagePrompt(decision.type, state, {
    recentEvent: options?.recentEvent ?? undefined,
    recentMessages: options?.recentFeedMessages,
    replyingTo: decision.replyTo,
  });

  try {
    const text = await generate(systemPrompt, userPrompt);

    // Clean up â€” strip quotes if the LLM wrapped its output
    const cleaned = text.trim().replace(/^["']|["']$/g, "").trim();
    if (!cleaned || cleaned.length > 500) return null; // Skip empty or too-long

    // Pick a target for mentions
    const target = decision.replyTo?.agentId
      ?? state.rivalAbove?.agentId
      ?? (state.zoneNeighbors.length > 0
        ? state.zoneNeighbors[Math.floor(Math.random() * state.zoneNeighbors.length)]
        : undefined);

    const msg: SocialMessage = {
      id: `msg-${Date.now()}-${messageCounter++}`,
      agentId: state.agentId,
      agentTitle: profile.title,
      agentEmoji: profile.emoji,
      archetype: profile.archetype,
      type: decision.type,
      text: cleaned,
      mood: profile.mood.current,
      zone: state.zone,
      timestamp: Date.now(),
      mentionsAgent: target,
      eventRelated: decision.type === "cosmic_reaction",
      replyTo: decision.replyTo?.id,
    };

    store.add(msg);
    return msg;
  } catch (err: any) {
    console.warn(`[Social] LLM generate failed for Agent #${state.agentId}: ${err.message}`);
    return null;
  }
}

let messageCounter = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IN-MEMORY MESSAGE STORE â€” Ring buffer for the feed
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export class SocialFeedStore {
  private messages: SocialMessage[] = [];
  private maxSize: number;

  constructor(maxSize = 1000) {
    this.maxSize = maxSize;
  }

  add(msg: SocialMessage): void {
    this.messages.push(msg);
    if (this.messages.length > this.maxSize) {
      this.messages = this.messages.slice(-this.maxSize);
    }
  }

  getRecent(count = 50): SocialMessage[] {
    return this.messages.slice(-count).reverse();
  }

  getByAgent(agentId: number, count = 20): SocialMessage[] {
    return this.messages
      .filter(m => m.agentId === agentId)
      .slice(-count)
      .reverse();
  }

  getByZone(zone: number, count = 30): SocialMessage[] {
    return this.messages
      .filter(m => m.zone === zone)
      .slice(-count)
      .reverse();
  }

  getByType(type: MessageType, count = 30): SocialMessage[] {
    return this.messages
      .filter(m => m.type === type)
      .slice(-count)
      .reverse();
  }

  getMentioning(agentId: number, count = 20): SocialMessage[] {
    return this.messages
      .filter(m => m.mentionsAgent === agentId)
      .slice(-count)
      .reverse();
  }

  /** Get conversation thread (a message and all replies) */
  getThread(messageId: string): SocialMessage[] {
    const root = this.messages.find(m => m.id === messageId);
    if (!root) return [];
    const replies = this.messages.filter(m => m.replyTo === messageId);
    return [root, ...replies];
  }

  getAll(): SocialMessage[] {
    return [...this.messages];
  }

  size(): number {
    return this.messages.length;
  }
}
